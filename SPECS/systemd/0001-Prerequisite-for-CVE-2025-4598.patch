From 7b05c955b76825bf34db6380f4e013dc5e87e03a Mon Sep 17 00:00:00 2001
From: akhila-guruju <v-guakhila@microsoft.com>
Date: Thu, 3 Jul 2025 09:14:18 +0000
Subject: [PATCH] Prerequisite for CVE-2025-4598

---
 man/version-info.xml                |  87 +++++++++
 src/basic/meson.build               |   2 +
 src/basic/missing_sched.h           |   5 +
 src/basic/namespace-util.c          |  42 ++++
 src/basic/namespace-util.h          |  21 ++
 src/basic/parse-util.c              |  15 ++
 src/basic/parse-util.h              |   1 +
 src/basic/pidref.c                  | 285 ++++++++++++++++++++++++++++
 src/basic/pidref.h                  |  65 +++++++
 src/basic/process-util.c            |  15 ++
 src/basic/process-util.h            |   2 +
 src/basic/stat-util.c               |  12 ++
 src/basic/stat-util.h               |   1 +
 src/core/namespace.c                |   1 +
 src/core/namespace.h                |  13 +-
 src/fundamental/macro-fundamental.h |   9 +
 16 files changed, 564 insertions(+), 12 deletions(-)
 create mode 100644 man/version-info.xml
 create mode 100644 src/basic/pidref.c
 create mode 100644 src/basic/pidref.h

diff --git a/man/version-info.xml b/man/version-info.xml
new file mode 100644
index 0000000..54440fe
--- /dev/null
+++ b/man/version-info.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0"?>
+<!DOCTYPE refsect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
+  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
+<!-- SPDX-License-Identifier: LGPL-2.1-or-later -->
+
+<refsect1>
+  <title/>
+
+  <para id="v183">Added in version 183.</para>
+  <para id="v184">Added in version 184.</para>
+  <para id="v185">Added in version 185.</para>
+  <para id="v186">Added in version 186.</para>
+  <para id="v187">Added in version 187.</para>
+  <para id="v188">Added in version 188.</para>
+  <para id="v189">Added in version 189.</para>
+  <para id="v190">Added in version 190.</para>
+  <para id="v191">Added in version 191.</para>
+  <para id="v192">Added in version 192.</para>
+  <para id="v193">Added in version 193.</para>
+  <para id="v194">Added in version 194.</para>
+  <para id="v195">Added in version 195.</para>
+  <para id="v196">Added in version 196.</para>
+  <para id="v197">Added in version 197.</para>
+  <para id="v198">Added in version 198.</para>
+  <para id="v199">Added in version 199.</para>
+  <para id="v200">Added in version 200.</para>
+  <para id="v201">Added in version 201.</para>
+  <para id="v202">Added in version 202.</para>
+  <para id="v203">Added in version 203.</para>
+  <para id="v204">Added in version 204.</para>
+  <para id="v205">Added in version 205.</para>
+  <para id="v206">Added in version 206.</para>
+  <para id="v207">Added in version 207.</para>
+  <para id="v208">Added in version 208.</para>
+  <para id="v209">Added in version 209.</para>
+  <para id="v210">Added in version 210.</para>
+  <para id="v211">Added in version 211.</para>
+  <para id="v212">Added in version 212.</para>
+  <para id="v213">Added in version 213.</para>
+  <para id="v214">Added in version 214.</para>
+  <para id="v215">Added in version 215.</para>
+  <para id="v216">Added in version 216.</para>
+  <para id="v217">Added in version 217.</para>
+  <para id="v218">Added in version 218.</para>
+  <para id="v219">Added in version 219.</para>
+  <para id="v220">Added in version 220.</para>
+  <para id="v221">Added in version 221.</para>
+  <para id="v222">Added in version 222.</para>
+  <para id="v223">Added in version 223.</para>
+  <para id="v224">Added in version 224.</para>
+  <para id="v225">Added in version 225.</para>
+  <para id="v226">Added in version 226.</para>
+  <para id="v227">Added in version 227.</para>
+  <para id="v228">Added in version 228.</para>
+  <para id="v229">Added in version 229.</para>
+  <para id="v230">Added in version 230.</para>
+  <para id="v231">Added in version 231.</para>
+  <para id="v232">Added in version 232.</para>
+  <para id="v233">Added in version 233.</para>
+  <para id="v234">Added in version 234.</para>
+  <para id="v235">Added in version 235.</para>
+  <para id="v236">Added in version 236.</para>
+  <para id="v237">Added in version 237.</para>
+  <para id="v238">Added in version 238.</para>
+  <para id="v239">Added in version 239.</para>
+  <para id="v240">Added in version 240.</para>
+  <para id="v241">Added in version 241.</para>
+  <para id="v242">Added in version 242.</para>
+  <para id="v243">Added in version 243.</para>
+  <para id="v244">Added in version 244.</para>
+  <para id="v245">Added in version 245.</para>
+  <para id="v246">Added in version 246.</para>
+  <para id="v247">Added in version 247.</para>
+  <para id="v248">Added in version 248.</para>
+  <para id="v249">Added in version 249.</para>
+  <para id="v250">Added in version 250.</para>
+  <para id="v251">Added in version 251.</para>
+  <para id="v252">Added in version 252.</para>
+  <para id="v253">Added in version 253.</para>
+  <para id="v254">Added in version 254.</para>
+  <para id="v255">Added in version 255.</para>
+  <para id="v256">Added in version 256.</para>
+  <para id="v257">Added in version 257.</para>
+  <para id="v258">Added in version 258.</para>
+  <para id="v259">Added in version 259.</para>
+  <para id="v260">Added in version 260.</para>
+</refsect1>
diff --git a/src/basic/meson.build b/src/basic/meson.build
index 229ac97..f82a2b1 100644
--- a/src/basic/meson.build
+++ b/src/basic/meson.build
@@ -177,6 +177,8 @@ basic_sources = files('''
         path-util.h
         percent-util.c
         percent-util.h
+	pidref.c
+	pidref.h
         prioq.c
         prioq.h
         proc-cmdline.c
diff --git a/src/basic/missing_sched.h b/src/basic/missing_sched.h
index 6a889f6..bcd5b77 100644
--- a/src/basic/missing_sched.h
+++ b/src/basic/missing_sched.h
@@ -7,6 +7,11 @@
 #define CLONE_NEWCGROUP 0x02000000
 #endif
 
+/* 769071ac9f20b6a447410c7eaa55d1a5233ef40c (5.8) */
+#ifndef CLONE_NEWTIME
+#define CLONE_NEWTIME 0x00000080
+#endif
+
 /* Not exposed yet. Defined at include/linux/sched.h */
 #ifndef PF_KTHREAD
 #define PF_KTHREAD 0x00200000
diff --git a/src/basic/namespace-util.c b/src/basic/namespace-util.c
index b9120a5..4a49a78 100644
--- a/src/basic/namespace-util.c
+++ b/src/basic/namespace-util.c
@@ -9,12 +9,30 @@
 #include "fileio.h"
 #include "missing_fs.h"
 #include "missing_magic.h"
+#include "missing_sched.h"
 #include "namespace-util.h"
 #include "process-util.h"
 #include "stat-util.h"
 #include "stdio-util.h"
 #include "user-util.h"
 
+const struct namespace_info namespace_info[] = {
+        [NAMESPACE_CGROUP] =  { "cgroup", "ns/cgroup", CLONE_NEWCGROUP,                          },
+        [NAMESPACE_IPC]    =  { "ipc",    "ns/ipc",    CLONE_NEWIPC,                             },
+        [NAMESPACE_NET]    =  { "net",    "ns/net",    CLONE_NEWNET,                             },
+        /* So, the mount namespace flag is called CLONE_NEWNS for historical
+         * reasons. Let's expose it here under a more explanatory name: "mnt".
+         * This is in-line with how the kernel exposes namespaces in /proc/$PID/ns. */
+        [NAMESPACE_MOUNT]  =  { "mnt",    "ns/mnt",    CLONE_NEWNS,                              },
+        [NAMESPACE_PID]    =  { "pid",    "ns/pid",    CLONE_NEWPID,                             },
+        [NAMESPACE_USER]   =  { "user",   "ns/user",   CLONE_NEWUSER,                            },
+        [NAMESPACE_UTS]    =  { "uts",    "ns/uts",    CLONE_NEWUTS,                             },
+        [NAMESPACE_TIME]   =  { "time",   "ns/time",   CLONE_NEWTIME,                            },
+        { /* Allow callers to iterate over the array without using _NAMESPACE_TYPE_MAX. */       },
+};
+
+#define pid_namespace_path(pid, type) procfs_file_alloca(pid, namespace_info[type].proc_path)
+
 int namespace_open(pid_t pid, int *pidns_fd, int *mntns_fd, int *netns_fd, int *userns_fd, int *root_fd) {
         _cleanup_close_ int pidnsfd = -1, mntnsfd = -1, netnsfd = -1, usernsfd = -1;
         int rfd = -1;
@@ -218,3 +236,27 @@ int userns_acquire(const char *uid_map, const char *gid_map) {
         return TAKE_FD(userns_fd);
 
 }
+
+int in_same_namespace(pid_t pid1, pid_t pid2, NamespaceType type) {
+        const char *ns_path;
+        struct stat ns_st1, ns_st2;
+
+        if (pid1 == 0)
+                pid1 = getpid_cached();
+
+        if (pid2 == 0)
+                pid2 = getpid_cached();
+
+        if (pid1 == pid2)
+                return 1;
+
+        ns_path = pid_namespace_path(pid1, type);
+        if (stat(ns_path, &ns_st1) < 0)
+                return -errno;
+
+        ns_path = pid_namespace_path(pid2, type);
+        if (stat(ns_path, &ns_st2) < 0)
+                return -errno;
+
+        return stat_inode_same(&ns_st1, &ns_st2);
+}
diff --git a/src/basic/namespace-util.h b/src/basic/namespace-util.h
index 24dce09..45f0318 100644
--- a/src/basic/namespace-util.h
+++ b/src/basic/namespace-util.h
@@ -3,6 +3,26 @@
 
 #include <sys/types.h>
 
+typedef enum NamespaceType {
+        NAMESPACE_CGROUP,
+        NAMESPACE_IPC,
+        NAMESPACE_NET,
+        NAMESPACE_MOUNT,
+        NAMESPACE_PID,
+        NAMESPACE_USER,
+        NAMESPACE_UTS,
+        NAMESPACE_TIME,
+        _NAMESPACE_TYPE_MAX,
+        _NAMESPACE_TYPE_INVALID = -EINVAL,
+} NamespaceType;
+
+extern const struct namespace_info {
+        const char *proc_name;
+        const char *proc_path;
+        unsigned int clone_flag;
+} namespace_info[_NAMESPACE_TYPE_MAX + 1];
+
+
 int namespace_open(pid_t pid, int *pidns_fd, int *mntns_fd, int *netns_fd, int *userns_fd, int *root_fd);
 int namespace_enter(int pidns_fd, int mntns_fd, int netns_fd, int userns_fd, int root_fd);
 
@@ -26,3 +46,4 @@ static inline bool userns_shift_range_valid(uid_t shift, uid_t range) {
 }
 
 int userns_acquire(const char *uid_map, const char *gid_map);
+int in_same_namespace(pid_t pid1, pid_t pid2, NamespaceType type);
diff --git a/src/basic/parse-util.c b/src/basic/parse-util.c
index 2888ab6..2e46acb 100644
--- a/src/basic/parse-util.c
+++ b/src/basic/parse-util.c
@@ -313,6 +313,21 @@ int parse_errno(const char *t) {
         return e;
 }
 
+int parse_fd(const char *t) {
+        int r, fd;
+
+        assert(t);
+
+        r = safe_atoi(t, &fd);
+        if (r < 0)
+                return r;
+
+        if (fd < 0)
+                return -EBADF;
+
+        return fd;
+}
+
 static const char *mangle_base(const char *s, unsigned *base) {
         const char *k;
 
diff --git a/src/basic/parse-util.h b/src/basic/parse-util.h
index 3dc5e14..4b21549 100644
--- a/src/basic/parse-util.h
+++ b/src/basic/parse-util.h
@@ -21,6 +21,7 @@ int parse_mtu(int family, const char *s, uint32_t *ret);
 int parse_size(const char *t, uint64_t base, uint64_t *size);
 int parse_range(const char *t, unsigned *lower, unsigned *upper);
 int parse_errno(const char *t);
+int parse_fd(const char *t);
 
 #define SAFE_ATO_REFUSE_PLUS_MINUS (1U << 30)
 #define SAFE_ATO_REFUSE_LEADING_ZERO (1U << 29)
diff --git a/src/basic/pidref.c b/src/basic/pidref.c
new file mode 100644
index 0000000..69b5cad
--- /dev/null
+++ b/src/basic/pidref.c
@@ -0,0 +1,285 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include "errno-util.h"
+#include "fd-util.h"
+#include "missing_syscall.h"
+#include "parse-util.h"
+#include "pidref.h"
+#include "process-util.h"
+#include "signal-util.h"
+
+int pidref_set_pid(PidRef *pidref, pid_t pid) {
+        int fd;
+
+        assert(pidref);
+
+        if (pid < 0)
+                return -ESRCH;
+        if (pid == 0)
+                pid = getpid_cached();
+
+        fd = pidfd_open(pid, 0);
+        if (fd < 0) {
+                /* Graceful fallback in case the kernel doesn't support pidfds or is out of fds */
+                if (!ERRNO_IS_NOT_SUPPORTED(errno) && !ERRNO_IS_PRIVILEGE(errno) && !ERRNO_IS_RESOURCE(errno))
+                        return -errno;
+
+                fd = -EBADF;
+        }
+
+        *pidref = (PidRef) {
+                .fd = fd,
+                .pid = pid,
+        };
+
+        return 0;
+}
+
+int pidref_set_pidstr(PidRef *pidref, const char *pid) {
+        pid_t nr;
+        int r;
+
+        assert(pidref);
+
+        r = parse_pid(pid, &nr);
+        if (r < 0)
+                return r;
+
+        return pidref_set_pid(pidref, nr);
+}
+
+int pidref_set_pidfd(PidRef *pidref, int fd) {
+        int r;
+
+        assert(pidref);
+
+        if (fd < 0)
+                return -EBADF;
+
+        int fd_copy = fcntl(fd, F_DUPFD_CLOEXEC, 3);
+        if (fd_copy < 0) {
+                pid_t pid;
+
+                if (!ERRNO_IS_RESOURCE(errno))
+                        return -errno;
+
+                /* Graceful fallback if we are out of fds */
+                r = pidfd_get_pid(fd, &pid);
+                if (r < 0)
+                        return r;
+
+                *pidref = PIDREF_MAKE_FROM_PID(pid);
+                return 0;
+        }
+
+        return pidref_set_pidfd_consume(pidref, fd_copy);
+}
+
+int pidref_set_pidfd_take(PidRef *pidref, int fd) {
+        pid_t pid;
+        int r;
+
+        assert(pidref);
+
+        if (fd < 0)
+                return -EBADF;
+
+        r = pidfd_get_pid(fd, &pid);
+        if (r < 0)
+                return r;
+
+        *pidref = (PidRef) {
+                .fd = fd,
+                .pid = pid,
+        };
+
+        return 0;
+}
+
+int pidref_set_pidfd_consume(PidRef *pidref, int fd) {
+        int r;
+
+        r = pidref_set_pidfd_take(pidref, fd);
+        if (r < 0)
+                safe_close(fd);
+
+        return r;
+}
+
+void pidref_done(PidRef *pidref) {
+        assert(pidref);
+
+        *pidref = (PidRef) {
+                .fd = safe_close(pidref->fd),
+        };
+}
+
+PidRef *pidref_free(PidRef *pidref) {
+        /* Regularly, this is an embedded structure. But sometimes we want it on the heap too */
+        if (!pidref)
+                return NULL;
+
+        pidref_done(pidref);
+        return mfree(pidref);
+}
+
+int pidref_dup(const PidRef *pidref, PidRef **ret) {
+        _cleanup_close_ int dup_fd = -EBADF;
+        pid_t dup_pid = 0;
+
+        assert(ret);
+
+        /* Allocates a new PidRef on the heap, making it a copy of the specified pidref. This does not try to
+         * acquire a pidfd if we don't have one yet!
+         *
+         * If NULL is passed we'll generate a PidRef that refers to no process. This makes it easy to copy
+         * pidref fields that might or might not reference a process yet. */
+
+        if (pidref) {
+                if (pidref->fd >= 0) {
+                        dup_fd = fcntl(pidref->fd, F_DUPFD_CLOEXEC, 3);
+                        if (dup_fd < 0) {
+                                if (!ERRNO_IS_RESOURCE(errno))
+                                        return -errno;
+
+                                dup_fd = -EBADF;
+                        }
+                }
+
+                if (pidref->pid > 0)
+                        dup_pid = pidref->pid;
+        }
+
+        PidRef *dup_pidref = new(PidRef, 1);
+        if (!dup_pidref)
+                return -ENOMEM;
+
+        *dup_pidref = (PidRef) {
+                .fd = TAKE_FD(dup_fd),
+                .pid = dup_pid,
+        };
+
+        *ret = TAKE_PTR(dup_pidref);
+        return 0;
+}
+
+int pidref_new_from_pid(pid_t pid, PidRef **ret) {
+        _cleanup_(pidref_freep) PidRef *n = 0;
+        int r;
+
+        assert(ret);
+
+        if (pid < 0)
+                return -ESRCH;
+
+        n = new(PidRef, 1);
+        if (!n)
+                return -ENOMEM;
+
+        *n = PIDREF_NULL;
+
+        r = pidref_set_pid(n, pid);
+        if (r < 0)
+                return r;
+
+        *ret = TAKE_PTR(n);
+        return 0;
+}
+
+int pidref_kill(const PidRef *pidref, int sig) {
+
+        if (!pidref)
+                return -ESRCH;
+
+        if (pidref->fd >= 0)
+                return RET_NERRNO(pidfd_send_signal(pidref->fd, sig, NULL, 0));
+
+        if (pidref->pid > 0)
+                return RET_NERRNO(kill(pidref->pid, sig));
+
+        return -ESRCH;
+}
+
+int pidref_kill_and_sigcont(const PidRef *pidref, int sig) {
+        int r;
+
+        r = pidref_kill(pidref, sig);
+        if (r < 0)
+                return r;
+
+        if (!IN_SET(sig, SIGCONT, SIGKILL))
+                (void) pidref_kill(pidref, SIGCONT);
+
+        return 0;
+}
+
+int pidref_sigqueue(const PidRef *pidref, int sig, int value) {
+
+        if (!pidref)
+                return -ESRCH;
+
+        if (pidref->fd >= 0) {
+                siginfo_t si;
+
+                /* We can't use structured initialization here, since the structure contains various unions
+                 * and these fields lie in overlapping (carefully aligned) unions that LLVM is allergic to
+                 * allow assignments to */
+                zero(si);
+                si.si_signo = sig;
+                si.si_code = SI_QUEUE;
+                si.si_pid = getpid_cached();
+                si.si_uid = getuid();
+                si.si_value.sival_int = value;
+
+                return RET_NERRNO(pidfd_send_signal(pidref->fd, sig, &si, 0));
+        }
+
+        if (pidref->pid > 0)
+                return RET_NERRNO(sigqueue(pidref->pid, sig, (const union sigval) { .sival_int = value }));
+
+        return -ESRCH;
+}
+
+int pidref_verify(const PidRef *pidref) {
+        int r;
+
+        /* This is a helper that is supposed to be called after reading information from procfs via a
+         * PidRef. It ensures that the PID we track still matches the PIDFD we pin. If this value differs
+         * after a procfs read, we might have read the data from a recycled PID. */
+
+        if (!pidref_is_set(pidref))
+                return -ESRCH;
+
+        if (pidref->pid == 1)
+                return 1; /* PID 1 can never go away, hence never be recycled to a different process → return 1 */
+
+        if (pidref->fd < 0)
+                return 0; /* If we don't have a pidfd we cannot validate it, hence we assume it's all OK → return 0 */
+
+        r = pidfd_verify_pid(pidref->fd, pidref->pid);
+        if (r < 0)
+                return r;
+
+        return 1; /* We have a pidfd and it still points to the PID we have, hence all is *really* OK → return 1 */
+}
+
+bool pidref_is_self(const PidRef *pidref) {
+        if (!pidref)
+                return false;
+
+        return pidref->pid == getpid_cached();
+}
+
+static void pidref_hash_func(const PidRef *pidref, struct siphash *state) {
+        siphash24_compress(&pidref->pid, sizeof(pidref->pid), state);
+}
+
+static int pidref_compare_func(const PidRef *a, const PidRef *b) {
+        return CMP(a->pid, b->pid);
+}
+
+DEFINE_HASH_OPS(pidref_hash_ops, PidRef, pidref_hash_func, pidref_compare_func);
+
+DEFINE_HASH_OPS_WITH_KEY_DESTRUCTOR(pidref_hash_ops_free,
+                                    PidRef, pidref_hash_func, pidref_compare_func,
+                                    pidref_free);
diff --git a/src/basic/pidref.h b/src/basic/pidref.h
new file mode 100644
index 0000000..dada069
--- /dev/null
+++ b/src/basic/pidref.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include "macro.h"
+
+/* An embeddable structure carrying a reference to a process. Supposed to be used when tracking processes continuously. */
+typedef struct PidRef {
+        pid_t pid; /* always valid */
+        int fd;    /* only valid if pidfd are available in the kernel, and we manage to get an fd */
+} PidRef;
+
+#define PIDREF_NULL (const PidRef) { .fd = -EBADF }
+
+/* Turns a pid_t into a PidRef structure on-the-fly *without* acquiring a pidfd for it. (As opposed to
+ * pidref_set_pid() which does so *with* acquiring one, see below) */
+#define PIDREF_MAKE_FROM_PID(x) (PidRef) { .pid = (x), .fd = -EBADF }
+
+static inline bool pidref_is_set(const PidRef *pidref) {
+        return pidref && pidref->pid > 0;
+}
+
+static inline bool pidref_equal(const PidRef *a, const PidRef *b) {
+
+        if (pidref_is_set(a)) {
+                if (!pidref_is_set(b))
+                        return false;
+
+                return a->pid == b->pid;
+        }
+
+        return !pidref_is_set(b);
+}
+
+/* This turns a pid_t into a PidRef structure, and acquires a pidfd for it, if possible. (As opposed to
+ * PIDREF_MAKE_FROM_PID() above, which does not acquire a pidfd.) */
+int pidref_set_pid(PidRef *pidref, pid_t pid);
+int pidref_set_pidstr(PidRef *pidref, const char *pid);
+int pidref_set_pidfd(PidRef *pidref, int fd);
+int pidref_set_pidfd_take(PidRef *pidref, int fd); /* takes ownership of the passed pidfd on success*/
+int pidref_set_pidfd_consume(PidRef *pidref, int fd); /* takes ownership of the passed pidfd in both success and failure */
+
+static inline int pidref_set_self(PidRef *pidref) {
+        return pidref_set_pid(pidref, 0);
+}
+
+bool pidref_is_self(const PidRef *pidref);
+
+void pidref_done(PidRef *pidref);
+PidRef *pidref_free(PidRef *pidref);
+DEFINE_TRIVIAL_CLEANUP_FUNC(PidRef*, pidref_free);
+
+int pidref_dup(const PidRef *pidref, PidRef **ret);
+
+int pidref_new_from_pid(pid_t pid, PidRef **ret);
+
+int pidref_kill(const PidRef *pidref, int sig);
+int pidref_kill_and_sigcont(const PidRef *pidref, int sig);
+int pidref_sigqueue(const PidRef *pidfref, int sig, int value);
+
+int pidref_verify(const PidRef *pidref);
+
+#define TAKE_PIDREF(p) TAKE_GENERIC((p), PidRef, PIDREF_NULL)
+
+extern const struct hash_ops pidref_hash_ops;
+extern const struct hash_ops pidref_hash_ops_free; /* Has destructor call for pidref_free(), i.e. expects heap allocated PidRef as keys */
diff --git a/src/basic/process-util.c b/src/basic/process-util.c
index c971852..b334bf5 100644
--- a/src/basic/process-util.c
+++ b/src/basic/process-util.c
@@ -34,6 +34,7 @@
 #include "missing_sched.h"
 #include "missing_syscall.h"
 #include "namespace-util.h"
+#include "parse-util.h"
 #include "path-util.h"
 #include "process-util.h"
 #include "raw-clone.h"
@@ -1535,6 +1536,20 @@ int pidfd_get_pid(int fd, pid_t *ret) {
         return parse_pid(p, ret);
 }
 
+int pidfd_verify_pid(int pidfd, pid_t pid) {
+        pid_t current_pid;
+        int r;
+
+        assert(pidfd >= 0);
+        assert(pid > 0);
+
+        r = pidfd_get_pid(pidfd, &current_pid);
+        if (r < 0)
+                return r;
+
+        return current_pid != pid ? -ESRCH : 0;
+}
+
 static int rlimit_to_nice(rlim_t limit) {
         if (limit <= 1)
                 return PRIO_MAX-1; /* i.e. 19 */
diff --git a/src/basic/process-util.h b/src/basic/process-util.h
index f22ff76..75fb486 100644
--- a/src/basic/process-util.h
+++ b/src/basic/process-util.h
@@ -14,6 +14,7 @@
 #include "alloc-util.h"
 #include "format-util.h"
 #include "macro.h"
+#include "namespace-util.h"
 #include "time-util.h"
 
 #define procfs_file_alloca(pid, field)                                  \
@@ -185,6 +186,7 @@ assert_cc(TASKS_MAX <= (unsigned long) PID_T_MAX);
         })
 
 int pidfd_get_pid(int fd, pid_t *ret);
+int pidfd_verify_pid(int pidfd, pid_t pid);
 
 int setpriority_closest(int priority);
 
diff --git a/src/basic/stat-util.c b/src/basic/stat-util.c
index efac7b0..f4476e3 100644
--- a/src/basic/stat-util.c
+++ b/src/basic/stat-util.c
@@ -408,6 +408,18 @@ int proc_mounted(void) {
         return r;
 }
 
+bool stat_inode_same(const struct stat *a, const struct stat *b) {
+
+        /* Returns if the specified stat structure references the same (though possibly modified) inode. Does
+         * a thorough check, comparing inode nr, backing device and if the inode is still of the same type. */
+
+        return a && b &&
+                (a->st_mode & S_IFMT) != 0 && /* We use the check for .st_mode if the structure was ever initialized */
+                ((a->st_mode ^ b->st_mode) & S_IFMT) == 0 &&  /* same inode type */
+                a->st_dev == b->st_dev &&
+                a->st_ino == b->st_ino;
+}
+
 bool stat_inode_unmodified(const struct stat *a, const struct stat *b) {
 
         /* Returns if the specified stat structures reference the same, unmodified inode. This check tries to
diff --git a/src/basic/stat-util.h b/src/basic/stat-util.h
index a566114..5cb2728 100644
--- a/src/basic/stat-util.h
+++ b/src/basic/stat-util.h
@@ -91,6 +91,7 @@ int device_path_parse_major_minor(const char *path, mode_t *ret_mode, dev_t *ret
 
 int proc_mounted(void);
 
+bool stat_inode_same(const struct stat *a, const struct stat *b);
 bool stat_inode_unmodified(const struct stat *a, const struct stat *b);
 
 int statx_fallback(int dfd, const char *path, int flags, unsigned mask, struct statx *sx);
diff --git a/src/core/namespace.c b/src/core/namespace.c
index c549dcc..2f0d60e 100644
--- a/src/core/namespace.c
+++ b/src/core/namespace.c
@@ -2816,6 +2816,7 @@ static const char* const namespace_type_table[] = {
         [NAMESPACE_USER]   = "user",
         [NAMESPACE_PID]    = "pid",
         [NAMESPACE_NET]    = "net",
+        [NAMESPACE_TIME]   = "time",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(namespace_type, NamespaceType);
diff --git a/src/core/namespace.h b/src/core/namespace.h
index 62f05d7..381d026 100644
--- a/src/core/namespace.h
+++ b/src/core/namespace.h
@@ -15,6 +15,7 @@ typedef struct MountImage MountImage;
 #include "dissect-image.h"
 #include "fs-util.h"
 #include "macro.h"
+#include "namespace-util.h"
 #include "string-util.h"
 
 typedef enum ProtectHome {
@@ -26,18 +27,6 @@ typedef enum ProtectHome {
         _PROTECT_HOME_INVALID = -EINVAL,
 } ProtectHome;
 
-typedef enum NamespaceType {
-        NAMESPACE_MOUNT,
-        NAMESPACE_CGROUP,
-        NAMESPACE_UTS,
-        NAMESPACE_IPC,
-        NAMESPACE_USER,
-        NAMESPACE_PID,
-        NAMESPACE_NET,
-        _NAMESPACE_TYPE_MAX,
-        _NAMESPACE_TYPE_INVALID = -EINVAL,
-} NamespaceType;
-
 typedef enum ProtectSystem {
         PROTECT_SYSTEM_NO,
         PROTECT_SYSTEM_YES,
diff --git a/src/fundamental/macro-fundamental.h b/src/fundamental/macro-fundamental.h
index f87839d..a8a59db 100644
--- a/src/fundamental/macro-fundamental.h
+++ b/src/fundamental/macro-fundamental.h
@@ -264,6 +264,15 @@
                 _ptr_;                          \
         })
 
+#define TAKE_GENERIC(var, type, nullvalue)                       \
+        ({                                                       \
+                type *_pvar_ = &(var);                           \
+                type _var_ = *_pvar_;                            \
+                type _nullvalue_ = nullvalue;                    \
+                *_pvar_ = _nullvalue_;                           \
+                _var_;                                           \
+        })
+
 /*
  * STRLEN - return the length of a string literal, minus the trailing NUL byte.
  *          Contrary to strlen(), this is a constant expression.
-- 
2.45.2

